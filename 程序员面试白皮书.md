##### 第2章 数组和字符串
###### 2.1 知识要点

* 2.1.1 数组
    * 一段连续的内存空间
    * 数组名是一个指针，指向这段内存的起始地址
    * 注意数组越界
    * 读取、修改的时间复杂度为`O(1)`
    * 插入、删除的时间复杂度为`O(n)`
* 2.1.2 哈希表
    * 存储的基本元素是键值对（`key-value pair`）
    * 使用者提供一个键，哈希表根据自己定义的哈希函数映射出一个下标，根据下标找到元素位置
    * 平均时间复杂度为`O(1)`
    * 解决冲突方式
        * 链接法（用链表或其他数据结构将冲突的元素链接起来）
        * 开放地址法（继续哈希，直到找到未使用的位置）
* 2.1.3 字符串
    * 在`C`语言中，字符串指的是一个以`'\0'`结尾的`char`数组

###### 2.2 模式识别

* 2.2.1 使用哈希表
    * 例一：判断一个字符串所有的字符是否都是唯一的（字符为键，次数为值，时间复杂度`O(n)`）
    * 例二：给定两个字符串，判断它们是否是彼此可置换的（每个字符串中字符的个数保存在哈希表中，比较两个哈希表，时间复杂度`O(n)`）
    * 例三：给定两个字符串`newspaper`和`message`，检查是否能够使用`newspaper`中的字母来组成`message`（如例二，对比后者每个字符的个数是否少于前者，时间复杂度`O(n)`）
* 2.2.2 利用哈希表实现动态规划的思想
    * 例一：从一个数组中找出一对元素，其和是一个给定的目标数字。假设数组只存在一个符合要求的数值对，返回这些数值的下标（例如返回`(i,j)`，较小的下标在前面）（扫描数组，将数组的元素作为键，下标作为值存储到哈希表中，然后此后的元素通过判断是否存在（总数-当前值）的键，来配对元素，时间复杂度`O(n)`）
    * 例二：获取一个数组中最长的连续的元素序列。例如给定了`[31,6,32,1,3,2]`，最长的连续的元素序列是`[1,2,3]`，返回其长度`3`（遍历数组，判断当前元素的值加减一是否在哈希表中，如果不在，将当前值分别作为最大最小值存入哈希表，当前值为键，最大最小值为值；如果在，则比较加减后的值所对应的最大最小值，将其记入当前值的最大最小值。时间复杂度`O(n)`。	[`demo`](https://github.com/smartdong/AlgorithmPractise/blob/master/Chips/FindLongestConsecutiveSequence.m)）
* 2.2.3 `string`相关问题的处理技巧
    * 例一：给定输入是“`I have 36 books, 40 pens2.`”，要求输出“`I evah 36 skoob, 40 2snep.`”（分成两个函数，一个负责切分单词，一个负责逆向单词，时间复杂度`O(n)`）
    * 例二：将字符串中的空格替换为“`%20`”。例如，给定“`Big mac`”，返回“`Big%20mac`”。（`So easy`，时间复杂度`O(n)`）
    * 例三：将字符串中的“`%20`”替换为空格。例如，给定“`Big%20mac`”，返回“`Big mac`”。（`So easy`，时间复杂度`O(n)`）

###### 2.3 工具箱

* 栈和堆（操作系统意义上的，而非数据结构意义上的）
    * 栈主要是指由操作系统自动管理的内存空间
    * 当进入一个函数时，操作系统通常会分配一个内存块叠加到当前的栈上，并利用指针指向前一个内存块，该内存块存储着当前函数的局部变量
    * 当函数返回时，系统“弹出”内存块，并根据指针回到前一个内存块
    * 通常在栈上分配的内存不需要用户关心
    * 堆是用来存储动态分布变量的空间
    * 通常需要自己管理堆上分配的内存，使用不当会造成内存泄露

##### 第3章 链表
###### 3.1 知识要点

* 链表是一种常见的线性数据结构
* 对于单向链表，每个节点有一个`next`指针指向后一个节点，还有一个成员变量用以存储数值
* 对于双向链表，还有一个`prev`指针指向前一个节点
* 和数组一样，搜索链表的时间复杂度为`O(n)`，但是链表不能像数组一样通过下标读取数据
* 链表的优势是能以较高的效率在任意节点插入或删除节点

###### 3.2 模式识别

* 3.2.1 链表的基本操作
    * 修改单向链表的操作只需要考虑
        * 哪个节点的`next`指针会收到影响，则需要修正该指针
        * 如果待删除节点是动态开辟的内存空间，则需要释放这部分空间 
    * 操作链表时需要注意的边界条件
        * `curr == head`
        * `curr == tail`
        * `curr == NULL`
* 3.2.2 哑节点
    * 哑节点（没有存储数据，只用来指向`head`节点）通常用于简化判断逻辑，不需要考虑边界条件
    * 例一：给定一个链表和一个值`x`，编写一个函数，对该链表重新排序，以便所有小于`x`的节点都出现在大于或等于`x`的节点的前面（[`demo`](https://github.com/smartdong/AlgorithmPractise/blob/master/Chips/Reorderlist.c)）
* 3.2.3 `Runner`和`Chaser`
    * 例一：给定一个链表，编写一个函数以返回该链表的中间点（[`demo`](https://github.com/smartdong/AlgorithmPractise/blob/master/Chips/Midpoint.c)）
    * 例二：找到一个单向链表中，距离最后一个元素为`k`的那个元素。例如给定一个链表`1->2->3->4`，并且`k`等于`2`，那么该函数应该返回`2`（[`demo`](https://github.com/smartdong/AlgorithmPractise/blob/master/Chips/FindkthtoLastNode.c)）
