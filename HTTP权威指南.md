####第一部分 `HTTP：Web`的基础
#####第1章 `HTTP`概述
######`URI`和`URL`

* `URI（Uniform Resource Identifier`）统一资源标识符，在世界范围内唯一标识并定位信息资源。`URI`有两种形式，分别称为`URL`和`URN`
* `URL` 统一资源定位符，描述了一台特定服务器上某资源的特定位置，现在几乎所有`URI`都是`URL`
* `URN` 统一资源名，作为特定内容的唯一名称使用，与目前的资源所在地无关（仍处于试验阶段）

######常见`HTTP`方法

* `GET` 从服务器向客户端发送命名资源
* `PUT` 将来自客户端的数据存储到一个命名的服务器资源中去
* `DELETE` 从服务器中删除命名资源
* `POST` 将客户端数据发送到一个服务器网关应用程序
* `HEAD` 仅发送命名资源响应中的`HTTP`首部

#####第2章 `URL`与资源
######`URL`组成

* `URL`的第一部分（`http`）是`URL`方案（`scheme`），方案可以告知`Web`客户端怎样访问资源
* `URL`的第二部分（`www.xxx.com`）指的是服务器位置，这部分告知`Web`客户端资源位于何处
* `URL`的第三部分（`/xxx/xxx.html`）是资源路径，路径说明了请求的是服务器上哪个特定的本地资源

######`URL`的语法  
`<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>`

#####第3章 `HTTP`报文 
######报文的组成部分

* 对报文进行描述的起始行（`start line`）
* 包含属性的首部（`header`）块
* 可选的、包含数据的主体（`body`）部分

######报文的语法

* 请求报文的格式  
	`<method> <request url> <version>`  
	`<headers>`  
	`<entity-body>`
* 响应报文的格式（只有起始行的语法有所不同）  
	`<version> <status> <reason-phrase>`  
	`<headers>`  
	`<entity-body>`

######状态码

* `100~199` 信息性状态码
    * `100 Continue` 说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务端在收到请求之后必须进行响应
    * `101 Switching Protocols` 说明服务器正在根据客户端的指定，将协议切换成`Update`首部所列的协议
* `200~299` 成功状态码
    * `200 OK` 请求没问题，实体的主体部分包含了所请求的资源
    * `201 Created` 用于创建服务器对象的请求，响应的实体主体部分中应该包含各种引用了已创建的资源的`URL`，`location`首部包含的则是最具体的引用
    * `202 Accepted` 请求已被接受，但服务器还未对其执行任何动作，不能保证服务器会完成这个请求
    * `203 Non-Authoritative Infomation` 实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本
    * `204 No Content` 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新
    * `205 Reset Content` 另一个主要用于浏览器的代码，负责告知浏览器清除当前页面中的所有`HTML`表单元素
    * `206 Partial Content` 成功执行了一个部分或`Range（范围）`请求，`206`响应中必须包含`Content-Range`、`Date`以及`ETag`或`Content-Location`首部
* `300~399` 重定向状态码
    * `300 Multiple Choices` 客户端请求一个实际指向多个资源的`URL`时会返回此状态码，返回时会带有一个选项列表供用户选择
    * `301 Moved Permanently` 在请求的`URL`已被移除时使用，响应的`Location`首部中应该包含资源现在所处的`URL`
    * `302 Found` 与`301`类似，但客户端应该使用`Location`首部给出的`URL`来临时定位资源，将来的请求仍应使用老的`URL`
    * `303 See Other` 告知客户端应该使用另一个`URL`来获取资源，新的`URL`位于响应报文的`Location`首部，主要目的是允许`POST`请求的响应将客户端定位到某个资源上去
    * `304 Not Modified` 客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起了一个条件`GET`请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改
    * `305 Use Proxy` 用来说明必须通过一个代理来访问资源，代理的位置由`Location`首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误的让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞
    * `306 (未使用)` 当前未使用
    * `307 Temporary Redirect` 与`301`类似，但客户端应该使用`Location`首部给出的`URL`来临时定位资源，将来的请求仍应使用老的`URL`
* `400~499` 客户端错误状态码
    * `400 Bad Request` 用于告知客户端它发送了一个错误的请求
    * `401 Unauthorized` 与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证
    * `402 Payment Required` 现在这个状态码还未使用，但已经被保留，以作未来之用
    * `403 Forbidden` 用来说明请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可以包 含实体的主体部分来对原因进行描述，但这个状态码通常是在服务器不想说明拒绝原因的时候使用的
    * `404 Not Found` 用于说明服务器无法找到所请求的`URL`，通常会包含一个实体，以便客户端应用程序显示给用户看
    * `405 Method Not Allowed` 发起的请求中带有所请求的`URL`不支持的方法时，使用此状态码。应该在响应中包含`Allow`首部，以告知客户端对所请求的资源可以使用哪些方法
    * `406 Not Acceptable` 客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的`URL`相匹配的资源时，使用此代码。通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足
    * `407 Proxy Authentication Required` 与`401`类似，但用于要求对资源进行认证的代理服务器
    * `408 Request Timeout` 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同有所不同，但通常对所有的合法请求来说都是够长的
    * `409 Conflict` 用于说明请求可能在资源上引发一些冲突。服务器担心请求会引发冲突时，可以发送此状态码，响应中应该包含描述冲突的主体
    * `410 Gone` 与`404`类似，只是服务器曾经拥有过此资源。主要用于`Web`站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了
    * `411 Length Required` 服务器要求在请求报文中包含`Content- Length`首部时使用
    * `412 Precondition Failed` 客户端发起了条件请求，且其中一个条件失败了的时候使用。客户端包含了`Expect`首部时发起的就是条件请求
    * `413 Request Entity Too Large` 客户端发送的实体主体部分比服务器能够或者希望处理的要大时使用
    * `414 Requets URL Too Long` 客户端所发请求中的请求`URL`比服务器能够或者希望处理的要长时使用
    * `415 Unsupported Media Type` 服务器无法理解或无法支持客户端所发实体的内容类型时使用
    * `416 Requested Range Not Satisfiable` 请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时使用
    * `417 Expectation Failed` 请求的`Expect`请求首部包含了一个期望，但服务器无法满足此期望时使用
* `500~599` 服务器错误状态码
    * `500 Internal Server Error` 服务器遇到一个妨碍它为请求提供服务的错误时使用
    * `501 Not Implemented` 客户端发起的请求超出服务器的能力范围时使用（比如使用了服务器不支持的请求方法）
    * `502 Bad Gateway` 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应时使用
    * `503 Service Unavailable` 用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器知道什么时候资源会变成可用的，可以在响应中包含一个`Retry-After`首部
    * `504 Gateway Timeout` 与`408`类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了
    * `505 HTTP Version Not Supported` 服务器收到的请求使用了它无法或不愿支持的协议版本时使用·

######首部

* 通用首部：客户端和服务器都可以使用的通用首部
* 请求首部：请求报文特有
    * `Accept`首部
    * 条件请求首部
    * 安全请求首部
    * 代理请求首部
* 响应首部：响应报文特有
    * 协商首部
    * 安全响应首部
* 实体首部：用于应对实体主体部分的首部
    * 内容首部
    * 实体缓存首部
* 扩展首部：非标准首部，由应用程序开发者创建

#####第4章 连接管理
######`Connection`首部处理

* `HTTP`应用程序收到一条带有`Connection`首部的报文时， 接收端会解析发送端请求的所有选项，并将其应用。然后会在将此报文转发给下一跳地址之前，删除`Connection`首部以及`Connection`中列出的所有首部。而且，可能还会有少量没有作为`Connection`首部值列出，但一定不能被代理转发的逐跳首部。其中包括`Proxy-Authenticate`、`Proxy-Connection`、`Transfer-Encoding`和`Upgrade`

######`Keep-Alive`连接的限制和规则

* 在`HTTP/1.0`中，`Keep-Alive`并不是默认使用的。客户端必须发送一个`Connection : Keep-Alive`请求首部来激活`Keep-Alive`连接
* `Connection : Keep-Alive`首部必须随所有希望保持持久连接的报文一起发送。如果客户端没有发送`Connection : Keep-Alive`首部，服务器就会在那条请求之后关闭连接
* 通过检测响应中是否包含`Connection : Keep-Alive`响应首部，客户端可以判断服务器是否会在发出响应之后关闭连接
* 只有在无需检测到连接的关闭即可确定报文实体主体部分长度的情况下，才能将连接保持在打开状态。也就是说实体的主体部分必须有正确的`Content-Length`，在一条`Keep-Alive`信道中回送错误的`Content-Length`是很糟糕的事情，这样事务处理的另一端就无法精确的检测出一条报文的结束和另一条报文的开始
* 代理和网关必须执行`Connection`首部的规则，必须在将报文转发出去或将其高速缓存之前，删除在`Connection`首部中命名的所有首部字段以及`Connection`首部自身
* 严格来说，不应该与无法确定是否支持`Connection`首部的代理服务器建立`Keep-Alive`连接，以防出现哑代理问题
* 从技术上来说，应该忽略所有来自`HTTP/1.0`设备的`Connection`首部字段（包括`Connection : Keep-Alive`），因为它们可能是由比较老的代理服务器误转发的
* 除非重复发送请求会产生其他一些副作用，否则如果在客户端收到完整的响应之前连接就关闭了，客户端就一定要做好重试请求的准备

######持久连接的限制和规则

* 发送了`Connection : close`请求首部之后，客户端就无法在那条连接上发送更多的请求了
* 如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个`Connection : close`请求首部
* 只有当连接上所有的报文都有正确的、自定义报文长度时——也就是说，实体主体部分的长度都和响应的`Content-Length`一致，或是用分块传输编码方式编码的——连接才会持久保持
* `HTTP/1.1`的代理必须能够分别管理与客户端和服务器的持久连接——每个持久连接都只适用于一跳传输
* （由于较老的代理会转发`Connection`首部，所以）`HTTP/1.1`的代理服务器不应该与`HTTP/1.0`客户端建立持久连接，除非它们了解客户端的处理能力（比较扯淡）
* 尽管服务器不应该试图在传输报文的过程中关闭连接，而且在关闭连接之前至少应该响应一条请求，但不管`Connection`首部取了什么值，`HTTP/1.1`设备都可以在任意时刻关闭连接
* `HTTP/1.1`应用程序必须能够从异步的关闭中恢复出来。只要不存在可能会累积起来的副作用，客户端都应该重试这条请求
* 除非重复发起请求会产生副作用，否则如果在客户端收到整条响应之前连接关闭了，客户端就必须要重新发起请求
* 一个用户客户端对任何服务器或代理最多只能维护两条持久连接，以防服务器过载。代理可能需要更多到服务器的连接来支持并发用户的通信，所以如果有`N`个用户试图访问服务器的话，代理最多要维持`2N`条到任意服务器或父代理的连接

######管道化连接的几条限制

* 如果`HTTP`客户端无法确认连接是持久的，就不应该使用管道
* 必须按照与请求相同的顺序回送`HTTP`响应。`HTTP`报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了
* `HTTP`客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求
* `HTTP`客户端不应该用管道化的方式发送会产生副作用的请求（比如`POST`）。总之，出错的时候，管道化方式会阻碍客户端了解服务器执行的是一系列管道化请求中的哪一些。由于无法安全的重试`POST`这样的非幂等请求，所以出错时，就存在某些方法永远不会被执行的风险

######幂等请求

* 如果一个事务，不管是执行一次还是很多次，得到的结果都相同，这个事务就是幂等的。

####第二部分 `HTTP`结构
#####第5章 `Web`服务器
######`Web`服务器任务基本流程

* 建立连接——接收一个客户端连接，或者如果不希望与这个客户端建立连接，就将其关闭
* 接收请求——从网络中读取一条`HTTP`请求报文
* 处理请求——对请求报文进行解释，并采取行动
* 访问资源——访问报文中指定的资源
* 构建响应——创建带有正确首部的`HTTP`响应报文
* 发送响应——将响应回送给客户端
* 记录事务处理过程——将与已完成事务有关的内容记录在一个日志文件中

#####第6章 代理
######代理的常见使用

* 儿童过滤器
* 文档访问控制
* 安全防火墙
* `Web`缓存
* 反向代理
* 内容路由器
* 转码器
* 匿名访问

######客户端流量流向代理的方法

* 修改客户端（手动设置）
* 修改网络（拦截网络流量）
* 修改`DNS`的命名空间（手动或动态修改`DNS`名称列表）
* 修改`Web`服务器（向客户端发送`HTTP`重定向命令）

#####第7章 缓存
######缓存的优点

* 减少了冗余的数据传输
* 缓解了网络瓶颈问题
* 降低了对原始服务器的要求
* 减低了距离延时

######缓存再验证规则

* 缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求，最常用的是在请求中加入`If-Modified-Since`首部
* 如果内容没有变化（再验证命中），服务器会以一个小的`304 Not Modified`进行响应
* 如果服务器对象与已缓存副本不同（再验证未命中），服务器会发送一条普通的、带有完整内容的`HTTP 200 OK`响应
* 如果服务器对象已经被删除了（对象被删除），服务器会回送`404 Not Found`，缓存也会将其副本删除

######缓存的处理步骤

* 接收——缓存从网络中读取抵达的请求报文
* 解析——缓存对报文进行解析，提取出`URL`和各种首部
* 查询——缓存查看是否有本地副本可用，如果没有就获取一份副本并保存在本地
* 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是就询问服务器是否有任何更新
* 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文
* 发送——缓存通过网络将响应发回客户端
* 日志——缓存可选的创建一个日志文件条目来描述这个事务

######在响应首部中控制缓存时间的方法：（按优先级递减）

* `Cache-Control : no-store`（不缓存）
* `Cache-Control : no-cache`（可以缓存，但是必须先验证才能提供给客户端）
* `Cache-Control : must-revalidate`（可以缓存，但是必须先验证才能提供给客户端）
* `Cache-Control : max-age`（缓存有效时间）
* `Expires`（缓存过期日期，不建议使用，因为服务器时间不一定同步）
* 不添加，让缓存确定自己的过期日期

#####第8章 集成点：网关、隧道及中继
######网关的概念

* 网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法
* 网关是资源和应用程序之间的粘合剂
* 应用程序可以（通过`HTTP`或其他已定义的接口）请求网关来处理某条请求，网关可以提供一条响应
* 网关可以向数据库发起查询语句，或是生成动态的内容，就像一个门一样：进去一条请求，出来一个响应

######协议网关

* `HTTP/*`：服务器端`Web`网关
* `HTTP/HTTPS`：服务器端安全网关
* `HTTPS/HTTP`：客户端安全加速器网关

######资源网关

* `CGI`（通用网关接口 `Common Gateway Interface`）
* 服务器扩展`API`

######隧道

* 用`CONNECT`建立`HTTP`隧道
* 数据隧道、定时及连接管理
* `SSL`隧道

######中继

* `HTTP`中继是没有完全遵循`HTTP`规范的简单`HTTP`代理
* 中继负责处理`HTTP`中建立连接的部分，然后对字节进行盲转发
* 中继无法正确处理`Connection`首部，所以有潜在的挂起`keep-alive`连接的可能

#####第9章 `Web`机器人
######爬虫及其爬行方式

* `Web`爬虫是一种机器人，它们会递归的对各种信息性`Web`站点进行遍历
* 爬虫需要一个根集，一个好的根集会包括一些大的流行站点
* 爬虫需要对`HTML`页面进行解析，提取出`URL`链接并将相对`URL`转化为绝对形式
* 避免循环常用的技术：
    * 树和散列表
    * 有损的存在位图
    * 检查点（储存爬过的链接）
    * 分类
    * 规范化`URL`
    * 广度优先的爬行
    * 节流（限制从同一个站点爬取的数量）
    * 限制`URL`大小
    * `URL`/站点黑名单
    * 模式检测（避免无限重复循环）
    * 内容指纹
    * 人工监视

#####第10章 `HTTP-NG`
######模块化及功能增强

* 第一层，报文传输层（`message transport layer`）。这一层不考虑报文的功能，而是致力于端点间报文的不透明传输
* 第二层，远程调用层（`remote invocation layer`）。定义了请求/响应的功能，客户端可以通过这些功能调用对服务器资源的操作，本层独立于报文的传输以及操作的精确语义，它只是提供了一种标准的方法来调用服务器上所有的操作
* 第三层，`Web`应用层（`Web application layer`）。提供了大部分的内容管理逻辑，还支持其他构建在远程调用基础上的服务

####第三部分 识别、认证与安全
#####第11章 客户端识别与`cookie`机制
######承载用户身份信息的`HTTP`首部

* `From`：用户的`E-mail`地址
* `User-Agent`：用户的浏览器软件
* `Referer`：用户是从这个页面上依照链接跳转过来的
* `Authorization`：用户名和密码
* `Client-IP`：客户端的`IP`地址
* `X-Forwarded-For`：客户端的`IP`地址
* `Cookie`：服务器产生的`ID`标签

######使用客户端`IP`地址的缺点

* 客户端`IP`地址描述的是所用的机器，而不是用户。如果多个用户共享一台计算机，就无法对其进行区分了
* 很多因特网服务提供商会在用户登录时为其动态分配`IP`地址
* 很多用户是通过防火墙来浏览网络内容的，防火墙隐藏了客户端的实际`IP`地址
* 如果使用了代理服务器，可能得到的会是代理服务器的`IP`地址

######用户登录

* 如果服务器希望在为用户提供对站点的访问之前，先行登录，可以向浏览器回送一条`HTTP`响应代码`401 Login Required`。然后浏览器会显示一个登录对话框，并用`Authorization`首部在下一条对服务器的请求中提供这些信息

######胖`URL`

* 有些`Web`站点会为每个用户生成特定版本的`URL`来追踪用户的身份，改动后包含了用户信息的`URL`被成为胖`URL`
* 胖`URL`的问题
    * 丑陋的`URL`
    * 无法共享
    * 破坏缓存
    * 额外的服务器负荷
    * 逃逸口（跳转到其他站点时容易丢失信息）
    * 在会话间是非持久的（除非收藏了`URL`，否则下次打开时信息已丢失）

######`cookie`

* `cookie`的类型
    * 会话`cookie`（临时，退出浏览器就被删除）
    * 持久`cookie`（存储在硬盘上，有过期时间）
* `cookie`是如何工作的
    * `cookie`中包含了一组（`name = value`）的值
    * 通过`Set-Cookie`或`Set-Cookie2`首部发送给服务器
* 不同站点使用不同的`cookie`
    * `cookie`的域属性（针对某站点使用）
    * `cookie`的路径属性（针对某路径使用）
* `cookie`缓存的指导性规则
    * 如果无法缓存文档，要将其标识出来（除了`Set-Cookie`首部可缓存：`Cache-Control:no-cache="Set-Cookie"`，或对可缓存的文档：`Cache-Control:public`）
    * 缓存`Set-Cookie`首部时要小心（使用`Cache-Control:must-revalidate,max-age=0`来强制缓存与原始服务器重新验证每条请求，并将`Set-Cookie`首部合并到客户端响应中）
    * 小心处理带有`cookie`首部的请求（缓存带有`cookie`首部的图片，过期时间设为零，强制每次都进行再验证）

#####第12章 基本认证机制
######认证协议与首部

* 质询：`www-Authenticate`（没有认证信息 请求方法`GET` 返回`401 Unauthorized`）
* 授权：`Authorization`（重新发送并带有`Authorization`首部 请求方法`Get`）
* 成功：`Authentication-Info`（如果授权证书正确则正常返回 `200 OK`）

######基本认证

* 请求资源
* 回送`401 Authorization Required`，同时回送`www-Authenticate`
* 弹出对话框，请求输入用户名密码
* 将用户名密码用冒号连接起来，并用`Base64`转换，然后放入`Authorization`首部回送
* 服务器解码，验证是否正确，返回`HTTP 200 OK`

######代理认证首部

* `Unauthorized status code : 407`（此项说明返回码不同，正常为401）
* `Proxy-Authenticate`
* `Proxy-Authorization`
* `Proxy-Authentication-Info`

######基本认证的安全缺陷

* 密码明文传输
* 用户名密码被截获，用于重复请求此接口或其他接口
* 用户名密码被截获，被撞库攻击其他网站
* 容易被钓鱼服务器骗取用户名密码

#####第13章 摘要认证
######摘要认证的改进

* 永远不会以明文方式在网络上发送密码
* 可以防止恶意用户捕获并重新认证的握手过程
* 可以有选择的防止对报文内容的篡改
* 防范其他几种常见的攻击方式

######摘要认证的握手机制

* 服务器计算出一个随机数
* 服务器将这个随机数放在`WWW-Authenticate`质询报文中，与服务器所支持的算法列表一同发往客户端
* 客户端选择一个算法，计算出密码和其他数据的摘要
* 客户端将摘要放在一条`Authorization`报文中发回服务器，如果客户端要对服务器进行认证，可以发送客户端随机数
* 服务器接收摘要、选中的算法以及支撑数据，计算出与客户端相同的摘要。然后服务器将本地生成的摘要与网络传送过来的摘要进行比较，验证其是否匹配。如果客户端反过来用客户端随机数来对服务器进行质询，就会创建客户端摘要。服务器可以预先将下一个随机数计算出来，提前将其传递给客户端，这样下一次客户端就可以预先发送正确的摘要了

######摘要的计算

* 摘要算法的三个组件（`H`和`KD`处理两块数据`A1`和`A2`，产生摘要）
    * 由单项散列函数`H(d)`和摘要`KD(s,d)`组成的一对函数，其中`s`表示密码，`d`表示数据
    * 一个包含了安全信息的数据块，包括密码，成为`A1`
    * 一个包含了请求报文中非保密属性的数据块，成为`A2`
* 算法`H(d)`和`KD(s,d)`
    * `RFC 2617`建议的两种算法为`MD5`和`MD5-sess`（`sess`表示会话）
    * 如果没有指定其他算法，默认算法为`MD5`
    * `MD5`和`MD5-sess`都会用函数`H`来计算数据的`MD5`，用摘要函数`KD`来计算以冒号链接的密码和非保密数据的`MD5`
* 与安全性相关的数据（`A1`）
    * 包含用户名、密码、保护域、随机数等内容，只涉及安全信息，与报文内容自身无关
    * `A1`会与`H`、`KD`和`A2`一同用于摘要计算
* 与报文有关的数据（`A2`）
    * 表示的是与报文自身有关的信息，比如`URL`、请求方法和报文实体的主体部分
    * `A2`会与`H`、`KD`和`A1`一同用于摘要计算
    * 第一种策略：当`qop="auth"`时，只包含`HTTP`请求方法和`URL`
    * 第二种策略：当`qop="auth-int"`时，添加报文实体的主体部分，以提供一定程度的报文完整性检测
* 摘要算法总述
    * 第一种方式要与老规范`RFC 2069`兼容，在没有`qop`选项的时候使用。它是用保密信息和随机报文数据的散列值来计算摘要的
    * 第二种方式是现在推荐使用的方式——这种方式包含了对随机数计算和对称认证的支持。只要`qop`为`auth`或`auth-int`，就要使用这种方式。它向摘要中添加了随机计数、`qop`和`cnonce`数据

######预授权方式

* 服务器预先在`Authentication-Info`成功首部中发送下一个随机数
* 服务器允许在一小段时间内使用同一个随机数
* 客户端和服务器使用同步的、可预测的随机数生成算法

#####第14章 安全`HTTP`
######安全`HTTP`技术期望的功能

* 服务器认证（客户端知道它们是在于真正的服务器通话）
* 客户端认证（服务器知道它们是在于真正的客户端通话）
* 完整性（客户端和服务器的数据不会被修改）
* 加密（客户端和服务器的对话是私密的，无须担心被窃听）
* 效率（一个运行的足够快的算法，以便低端的客户端和服务器使用）
* 普适性（基本上所有的客户端和服务器都支持这些协议）
* 管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）
* 适应性（能够支持当前最知名的安全方法）
* 在社会上的可行性（满足社会的政治文化需要）

######相关术语解释

* 对称密钥加密技术
    * 发送端和接收端要共享相同的密钥`k`才能进行通信
    * 发送端用共享的密钥加密并发送，接收端用解密函数和共享密钥恢复出原始明文
    * 为避免攻击者使用枚举法遍历所有可能的密钥，增加密钥长度可有效提高安全性
    * 对称密钥加密技术的缺点之一就是在发送者和接收者对话之前，一定要有一个共享的保密密钥。这会造成大量密钥，难以管理
* 公开密钥加密技术
    * 使用两个非对称密钥：一个用来对主机报文编码，一个用来对主机报文解码
    * 编码密钥是大家都知道的（公钥），解码密钥只有服务器才知道（私钥）
    * `RSA`算法是较常用的公开密钥加密系统
* 混合加密系统和会话密钥
    * 公开密钥加密算法的计算可能会很慢，实际上它混合使用了对称和非对称策略
    * 常见做法是在两节点间通过便捷的公开密钥加密技术建立起安全通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密
* 数字签名
    * 数字签名是附加在报文上的特殊加密校验码
    * 签名可以证明是作者编写了这条报文（只有作者才有私钥，才能计算出校验和）
    * 签名可以防止报文被篡改（校验和只有私钥才能产生，无法伪造）
* 数字证书
    * 包含了由某个受信任组织担保的用户或公司的信息：
    * 对象名称（人、服务器、组织等）
    * 过期时间
    * 证书发布者（担保者）
    * 来自证书发布者的证书签名
    * 公开密钥
    * 所用签名算法的描述性信息

######`HTTPS`概述

* `HTTPS`就是在安全的传输层上发送的`HTTP`
* 它在将`HTTP`报文发送给`TCP`之前，先将其发送给了一个安全层，对其进行加密
* 现在，`HTTP`安全层是通过`SSL`及其现代替代协议`TLS`来实现的。我们遵循常见的用法，用术语`SSL`来表示`SSL`或者`TLS`

######客户端（浏览器）对`URL`方案的检查

* 如果`URL`的方案为`HTTP`，客户端就会打开一条到服务器端口`80`（默认情况下）的连接，并向其发送老的`HTTP`命令
* 如果`URL`的方案为`HTTPS`，客户端就会打开一条到服务器端口`443`（默认情况下）的连接，然后与服务器“握手”，以二进制格式与服务器交换一些`SSL`安全参数，附上加密的`HTTP`命令

######`SSL`握手

* 交换协议版本号
* 选择一个两端都了解的密码
* 对两端的身份进行认证
* 生成临时的会话秘钥，以便加密信道

######站点证书的有效性

* 日期检测
* 签名颁发者可信度检测
* 签名检测
* 站点身份检测

####第四部分 实体、编码与国际化
#####第15章 实体与编码
######`HTTP/1.1`版定义的基本实体首部字段

* `Content-Type` 实体中所承载对象的类型
* `Content-Length` 所传送实体主体的长度或大小
* `Content-Language` 与所传送对象最相配的人类语言
* `Content-Encoding` 对象数据所做的任意变换（比如压缩）
* `Content-Location` 一个备用位置，请求时可通过它获取对象
* `Content-Range` 如果这是部分实体，这个首部说明它是整体的哪个部分
* `Content-MD5` 实体主体内容的校验和
* `Last-Modified` 所传输内容在服务器上创建或最后修改的日期时间
* `Expires` 实体数据将要失效的日期时间
* `Allow` 该资源所允许的各种请求方法（`GET`、`POST`等）
* `ETag` 这份文档特定实例的唯一验证码（`ETag`首部没有正式定义为实体首部，但它对许多涉及实体的操作来说，都是一个重要的首部）
* `Cache-Control` 指出应该如何缓存该文档（也没有正式定义为实体首部）

######实体主体

* 实体主体只是原始数据，所以需要实体首部来描述数据的意义（描述性的信息都包含在首部中）
* 首部字段已一个空白的`CRLF`行结束，随后就是实体主体的原始内容

######`Content-Length`：实体的大小

* `Content-Length`是实体主体的大小
* 如果主体被压缩，`Content-Length`就是被压缩后的大小，而不是原始大小
* `Content-Length`是为了能够检测出服务器崩溃而导致的报文截尾，并对共享持久连接的多个报文进行正确分段
* `Content-Length`对于持久连接是必不可少的
* 确定实体主体长度的规则
    * 如果报文类型不允许带有主体，就忽略`Content-Length`（比如`HEAD`方法）
    * 如果报文中含有描述传输编码的`Transfer-Encoding`首部（不采用默认的`HTTP`“恒等”编码），那实体就应由一个称为“零字节块”的特殊模式结束，除非报文已经因连接关闭而结束
    * 如果报文中含有`Content-Length`首部（并且报文类型允许有实体主体），而且没有非恒等的`Transfer-Encoding`首部字段，那么`Content-Length`的值就是主体的长度。如果收到的报文中既有`Content-Length`首部字段又有非恒等的`Transfer-Encoding`首部字段，那就必须忽略`Content-Length`，因为传输编码会改变实体主体的表示和传输方式（因此可能会改变传输的字节数）
    * 如果报文使用了`multipart/byteranges`媒体类型，并且没有用`Content-Length`首部指出实体主体的长度，那么多部分报文中的每个部分都要说明它自己的大小。这种多部分类型是唯一的一种自定界的实体主体类型，因此除非发送方知道接收方可以解析它，否则就不能发送这种媒体类型
    * 如果上面的规则都不匹配，实体就在连接关闭的时候结束。实际上，只有服务器可以使用连接关闭来指示报文的结束。客户端不能用关闭连接来指示客户端报文的结束，因为这样会使服务器无法发回响应

######实体摘要

* 使用`Content-MD5`首部发送对实体主体运行`MD5`算法的结果
* 只有产生响应的原始服务器可以计算并发送`Content-MD5`首部，中间代理和缓存不应当修改或添加这个首部
* `Content-MD5`首部是在对内容做了所有需要的内容编码之后，还没有做任何传输编码之前，计算出来的。为了验证报文的完整性，客户端必须先进行传输编码的解码，然后计算所得到的未进行传输编码的实体主体的`MD5`

######媒体类型和字符集

* `Content-Type`首部字段说明了实体主体的`MIME`类型
* `MIME`类型是标准化的名字，用以说明实体的基本媒体类型
* `Content-Type`首部还支持可选的参数来进一步说明内容的类型，比如`charset`参数（`Content-Type：text/html; charset=iso-8859-4`）

######内容编码

* 内容编码过程
    * 网站服务器生成原始响应报文，其中有原始的`Content-Type`和`Content-Length`首部
    * 内容编码服务器（可能是原始服务器或代理）创建编码后的报文。编码后的报文有同样的`Content-Type`但`Content-Length`可能不同（被压缩）。内容编码服务器在编码后的报文中增加`Content-Encoding`首部，这样接收的应用程序就可以进行解码了
    * 接收程序得到编码后的报文，进行解码，获得原始报文
* 内容编码类型
    * `Content-Encoding`首部是用标准化的代号来说明编码时使用的算法（如`gzip`、`compress`等）
    * 客户端使用`Accept-Encoding`首部通知服务器自己支持的编码类型
    * 如果客户端请求中没有包含`Accept-Encoding`首部，服务器假设客户端能够接受任何编码方式（等同于发送`Accept-Encoding：*`）

######传输编码和分块编码

* 使用传输编码是为了改变报文中的数据在网络上传输的方式
* 某些情况下，使用传输编码能得到更可靠的传输
    * 未知尺寸
    * 安全性（由于`HTTPS`流行，很少需要使用这种方式了）
* 使用`Transfer-Encoding`首部描述使用了何种编码
* 使用`TE`首部告知服务器可以使用哪些传输编码扩展
* 分块编码
    * 分块编码是一种传输编码，是报文的属性，不是主体的属性
    * 若客户端和服务器之间不是持久连接，客户端不需要知道它正在读取的主体长度，只需要读到服务器关闭主体连接为止
    * 当使用持久连接时，在服务器写主体之前，必须知道它的大小并在`Content-Length`首部中发送。但当无法知道主体长度时，可以使用分块编码解决：允许服务器把主体逐块发送，说明每块的大小就可以了
* 内容编码和传输编码可以同时使用
* 传输编码的规则
    * 传输编码集合中必须包括“分块”，唯一的例外是使用关闭连接来结束报文
    * 当使用分块传输编码时，它必须是最后一个作用到报文主体之上的
    * 分块传输编码不能多次作用到一个报文主体上

######验证码和新鲜度

* 新鲜度
    * 服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的
    * 服务器用两个首部来提供这个信息：`Expires`和`Cache-Control`
* 有条件的请求和验证码
    * 有条件的请求是标准的`HTTP`请求，但仅当某个特定条件为真时才才执行（例如`If-Modified-Since`）
    * 验证码是文档实例的一个特殊属性，用它来测试条件是否为真，每个有条件的请求都通过特定的验证码来发挥作用（常用的两个：`Last-Modified`和`ETag`）
    * 验证码分为强验证码和弱验证码。当文档改变时，强验证吗一定会改变，弱验证码则不一定改变

######范围请求

* 客户端可以通过范围请求来获取实体的某个范围（断点下载）
* 服务器可以通过在响应中包含`Accept-Ranges`首部的形式向客户端说明可以接受的范围请求，这个首部的值是计算范围的单位，通常是以字节计算

######差异编码

* 差异编码是`HTTP`协议的一个扩展，它通过交换对象改变的部分而不是完整的对象来优化传输性能
* 差异编码使用的首部：
    * `ETag` 文档唯一标识符
    * `If-None-Match` 客户端请求首部，当且仅当文档变化时才请求
    * `A-IM` 客户端请求首部，说明可以接受的实例操控类型
    * `IM` 服务器响应首部，说明作用在响应上的实例操控的类型
    * `Delta-Base` 服务器响应首部，说明用于计算差异的基线文档的`ETag`值

#####第16章 国际化
######`HTTP`对国际性内容的支持

    * 服务器通过`Content-Type`首部中的`charset`参数和`Content-Language`首部告知客户端文档的字母表和语言
    * 客户端发送`Accept-Charset`首部和`Accept-Language`首部告知服务器它理解哪些字符集编码算法和语言，以及其中的优先顺序

######字符集与`HTTP`

* 字符集是把字符转换为二进制码的编码
* 二进制码转换为字符的步骤
    * 文档中的二进制码被转换成字符代码，它表示了特定编码字符集中某个特定编号的字符
    * 字符代码用于从编码的字符集中选择特定的元素

#####第17章 内容协商与转码
######内容协商技术

* 客户端驱动
    * 客户端发起请求，服务器发送可选项的列表，客户端选择
    * 优点：在服务器端的实现最容易，客户端可以选择最合适的内容
    * 缺点：增加了时延，为了获得正确的内容，至少要发送两次请求
* 服务器驱动
    * 服务器检查客户端的请求首部并决定提供哪个版本的页面
    * 优点：比客户端驱动的协商方式要快；`HTTP`提供了`q`值机制，允许服务器近似匹配，还提供了`vary`首部供服务器告知下游的设备如何对请求估值
    * 缺点：如果结论不是很明确（比如首部集不匹配），服务器要做猜测
* 透明
    * 某个中间设备（通常是缓存代理）代表客户端进行请求协商
    * 优点：免除了`Web`服务器的协商开销，比客户端驱动的协商要快
    * 缺点：还没有正式的规范

######转码

* 格式转换：将数据从一种格式转换为另外一种格式，方便客户端查看
* 信息综合：从文档中提取关键的信息片段（比如根据小节标题生成文档的大纲）
* 内容注入：在页面中动态增加内容（比如自动广告生成器，呵呵）

####第五部分 内容发布与分发
#####第18章 `Web`主机托管
######在`HTTP/1.0`规范下让虚拟主机托管正常工作

* 通过`URL`路径进行虚拟主机托管
    * 在`URL`中增添专门的路径部分，以便服务器判断是哪个网站
    * 很糟糕的方案，很少会用到
* 通过端口号进行主机托管
    * 为每个站点分配不同的端口号，这样请求就由`Web`服务器的单独实例来处理
    * 不是很方便，也很少用
* 通过`IP`地址进行主机托管
    * 为不同的虚拟站点分配专门的`IP`地址，把这些地址都绑定到一台单独的机器
上，这样`Web`服务器就可以通过`IP`地址来识别网站名了
    * 在计算机系统上能绑定的虚拟`IP`地址通常是有限的，不一定能满足大量托管的需求
    * `IP`地址是稀缺资源，这种做法会需要使用大量的`IP`地址
    * 虽然会有消耗`IP`地址的问题，这个方案仍然得到了广泛运用
* 通过`Host`首部进行主机托管
    * `Web`服务器可以通过`Host`首部识别虚拟站点
    * 绝大多数现代浏览器和服务器都支持`Host`首部

######`HTTP/1.1`的`Host`首部

* 语法与用法
    * `Host = "Host" ":" host [ ":" port]`
    * 如果`Host`首部不包含端口，就使用地址方案中默认的端口
    * 如果`URL`中包含`IP`地址，`Host`首部就应当包含同样的地址
    * 如果`URL`中包含主机名，`Host`首部就必须包含同样的名字
    * 如果`URL`中包含主机名，`Host`首部就不应当包含`URL`中这个主机名对应的`IP`地址，因为这样会扰乱虚拟主机托管服务器的工作，它在同一个`IP`地址上堆叠了很多虚拟站点
    * 如果`URL`中包含主机名，`Host`首部就不应当包含这个主机名的其他别名，因为这样也会扰乱虚拟主机托管服务器的工作
    * 如果客户端显式的使用代理服务器，客户端就必须把原始服务器，而不是代理服务器的名字和端口放在`Host`首部中。以往，若干个`Web`客户端在启用客户端代理设置时，错误的把发出的`Host`首部设置成代理的主机名。这种错误的行为会使代理和原始服务器都无法正常处理请求
    * `Web`客户端必须在所有请求报文中包含`Host`首部
    * `Web`代理必须在转发请求报文之前，添加`Host`首部
    * `HTTP/1.1`的`Web`服务器必须用`400`状态码来响应所有缺少`Host`首部字段的`HTTP/1.1`请求报文

######解释`Host`首部

* 对于没有进行虚拟主机托管，而且不允许资源随请求主机的不同而变化的原始服务器来说，可以忽略`Host`首部字段
* 对于资源会随主机名的不同而变化的原始服务器，都必须在一条`HTTP/1.1`请求判断其所请求的资源时使用下列规则：
    * 如果`HTTP`请求报文中的`URL`是绝对的（包含方案和主机部分），就忽略`Host`首部字段
    * 如果`HTTP`请求报文中的`URL`没有主机部分，而该请求带有`Host`首部，则主机/端口的值就从`Host`首部中取
    * 如果通过第（1）步或第（2）步都无法获得有效的主机，就向客户端返回`400 Bad Request`响应

#####第19章 发布系统
######`WebDAV（Web Distributed Authoring and Versioning，分布式写作与版本管理）`的方法

* `PROPFIND` 获取资源的属性
* `PROPPATCH` 在一个或多个资源上设定一个或多个属性
* `MKCOL` 创建集合
* `COPY` 从指定的源端把资源或者资源集合复制到指定的目的地，目的地可以在另一台机器上
* `MOVE` 从指定的源端把资源或者资源集合移动到指定的目的地，目的地可以在另一台机器上
* `LOCK` 锁定一个或多个资源
* `UNLOCK` 把先前锁定的资源解锁

#####第20章 重定向与负载均衡
######为什么要重定向

* 可靠地执行`HTTP`事务
* 最小化时延
* 节约网络带宽

######`HTTP`应用程序和路由设备对报文传输方向影响的示例

* 配置创建客户端报文的浏览器应用程序，使其将报文发送给代理服务器
* `DNS`解析程序会选择用于报文寻址的`IP`地址。对不同物理地域的不同客户端来说，这个`IP`地址可能不同
* 报文经过网络传输时，会被划分为一些带有地址的分组；交换机和路由器会检查分组中的`TCP/IP`地址，并据此来确定分组的发送路线
* `Web`服务器可以通过`HTTP`重定向将请求反弹给不同的`Web`服务器

######通用的重定向方法

* `HTTP`重定向
    * 服务器返回`302`，重定向到其他服务器
    * 优点：重定向服务器知道客户端`IP`地址
    * 缺点：需要原始服务器进行大量处理来判断要重定向到哪台服务器上去（有时发布重定向所需的处理量几乎与提供页面本身所需的处理量一样）
    * 缺点：增加了用户时延，因为访问页面时要进行两次往返
    * 缺点：如果重定向服务器出故障，站点就会瘫痪
* `DNS`重定向
    * `DNS`轮转
    * 由于`DNS`查找结果会被缓存，所以一个客户端通常在很长时间内只连接到一台服务器上
    * 负载均衡算法：有些`DNS`服务器会跟踪`Web`服务器上的负载，将负载最轻的`Web`服务器放在列表的最前面
    * 邻接路由算法：`Web`服务器集群在地理上分散时，`DNS`服务器会尝试着将用户导向最近的`Web`服务器
    * 故障屏蔽算法：`DNS`服务器可以监视网络的状况，并将请求绕过出现服务中断或其他故障的地方
* 任播寻址
    * 几个地理上分散的`Web`服务器拥有完全相同的`IP`地址，而且会通过骨干路由器的“最短路径”路由功能将客户端的请求发送给离它最近的服务器
    * 每台服务器都要向邻近的骨干路由器广告，表明自己是一台路由器
    * `Web`服务器会通过路由器通信协议与其邻近的骨干路由器通信
    * 骨干路由器收到发送给任播地址的分组时，会寻找接受那个`IP`地址的最近的“路由器”
* `IP MAC`转发
    * `HTTP`报文数组分组中的第二层地址是`MAC`地址，第二层设备（比如交换机）会接收具有特定输入`MAC`地址的数据分组，并将其转发到特定`MAC`地址上去
    * 支持`MAC`地址转发的第四层交换机通常会将请求转发给几个代理缓存，并在它们中间平衡负载
    * 因为`MAC`地址转发只是点对点的，所以服务器或代理只能位于离交换机一跳远的地方
* `IP`地址转发
    * 交换机或其他第四层设备会检测输入分组中的`TCP/IP`地址，并通过修改目的`IP`地址，对分组进行响应的转发
    * 这种类型的转发也被称为`NAT（Network Address Translation 网络地址交换）`

######代理与缓存重定向技术

* 显式浏览器配置
    * 在浏览器菜单中输入代理的名字或`IP`地址以及端口号
    * 缺点：配置为使用代理的浏览器，即使在代理无法响应的情况下，也不会去联系原始服务器。如果代理崩溃了或者没有正确配置浏览器，用户就会遇到连接方面的问题
    * 缺点：对网络架构进行修改，并将这些修改通知给所有的终端用户都是很困难的。如果服务提供商要添加更多的代理服务器，或者使其中一些退出服务，用户都要修改浏览器代理设置
* 代理自动配置（`PAC`）
    * 基本思想是让浏览器去获取一个称为`PAC`的特殊文件，这个文件说明了每个`URL`所关联的代理。配置浏览器，为这个`PAC`文件关联一个特定的服务器，这样浏览器每次重启的时候都可以获取这个`PAC`文件
* `Web Proxy`代理自动发现协议（`WPAD`）
    * `PAC`文件自动发现
    * `WPAD`算法
    * 用`DHCP`进行`CURL`发现
    * `DNS` `A`记录查找
* `Web`缓存协调协议（`WCCP`）
    * `WCCP`重定向在`HTTP`上工作过程的概述如下：
    * 启动包含了一些支持`WCCP`的路由器和缓存的网络，这些路由器和缓存之间可以相互通信
    * 一组路由器及其目标缓存构成一个`WCCP`服务组。服务组的配置说明了要将何种流量发往何处、流量是如何发送的以及如何在服务组的缓存之间进行负载均衡
    * 如果服务组配置为重定向`HTTP`流量，服务组中的路由器就会将`HTTP`请求发送给服务组中的缓存
    * `HTTP`请求抵达服务组中的路由器时，路由器会（根据对请求`IP`地址的散列，或者“掩码/值”的配对策略）选择服务组中的某个缓存为请求提供服务
    * 路由器向缓存发送请求分组，可以用缓存的`IP`地址来封装分组，也可以通过`IP MAC`转发来实现
    * 如果缓存无法为请求提供服务，就将分组返回给路由器进行普通的转发
    * 服务组中的成员会互相交换心跳报文，不断验证对方的可用性
* 因特网缓存协议（`ICP`）
    * `ICP`允许缓存在其兄弟缓存中查找命中内容，可以把它当做一个缓存集群协议。从这个角度来说，它就是一个重定向协议
    * `ICP`是一个对象发现协议，它会同时去询问附近的多个缓存，看看它们的缓存中是否有特定的`URL`
    * `ICP`简单直接，采用`UDP`数据承载报文
* 缓存阵列路由协议（`CARP`）
    * `CARP`是`ICP`的一个替代品，`CARP`和`ICP`都允许管理者通过使用多个代理服务器来提高性能
    * `ICP`中出现缓存未命中时，代理服务器会用`ICP`报文格式轮询附近的缓存，而`CARP`只会通过散列表将请求映射到特定的代理服务器上，不会轮询每个代理服务器
* 超文本缓存协议（`HTCP`）
    * `HTCP`允许兄弟缓存之间通过`URL`和所有的请求及响应首部来相互查询文档是否存在，以降低错误命中的可能
    * `HTCP`允许兄弟缓存监视或请求在对方的缓存中添加或删除所选中的文档，并修改对方已缓存文档的缓存策略
    * `ICP`和`HTCP`事务之间的区别体现在请求和响应细节上

#####第21章 日志记录与使用情况跟踪
######通常会记录的基本信息

* `HTTP`方法
* 客户端和服务器的`HTTP`版本
* 所请求资源的`URL`
* 响应的`HTTP`状态码
* 请求和响应报文的尺寸（包含所有的实体主体部分）
* 事务开始时的时间戳
* `Referer`首部和`User-Agent`首部的值

######常用日志格式字段

* `remotehost` 请求端机器的主机名或`IP`地址（如果没有配置服务器去执行反向`DNS`或无法查找请求端的主机名，就使用`IP`地址）
* `username` 如果执行了`ident`查找，就是请求端已认证的用户名
* `auth-username` 如果进行了认证，就是请求端已认证的用户名
* `timestamp` 请求的日期和时间
* `request-line` 精确的`HTTP`请求行文本（`GET /index.html HTTP/1.1`）
* `response-code` 响应中返回的`HTTP`状态码
* `response-size` 响应主体中的`Content-Length`，如果响应中没有返回主体，就记录`0`

######新加的组合日志格式字段

* `Referer` `Referer`首部的内容
* `User-Agent` `User-Agent`首部的内容

######命中率测量

* 由于使用缓存服务器会导致日志文件记录缺失，所以服务器会对其最重要的页面设置为无法缓存（缓存清除）
* 由于代理缓存会保留日志，所以如果服务器能够访问这些日志，就可以避免使用缓存清除
* 命中率测量协议是对`HTTP`的一种扩展，它要求缓存周期性的向原始服务器汇报缓存访问的统计数据
* 命中率测量协议不是解决日志访问问题的完整解决方案，但是它提供了一种基本方式，而不是把内容标记为不可缓存的
* 命中率测量扩展建议使用新增加的首部`Meter`，缓存和服务器可以通过它在相互间传输与用法和报告有关的指令，这与用来进行缓存指令交换的`Cache-Control`首部很类似
